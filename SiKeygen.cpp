#include "pch.h"
#include "SiKeygen.h"
#include <sddl.h>
#include <sstream>
#include <fstream>
#include "CCBase64.h"
#include <vector>

const BYTE enc_tbl[] = { 
    0x32, 0xDF, 0x71, 0xB7, 0x61, 0x3D, 0x6B, 0x57, 0xD7, 0xA1,
    0x34, 0x38, 0xF2, 0xE1, 0xF3, 0xB8, 0x23, 0xDD, 0x78, 0xB5,
    0x33, 0x6F, 0xD4, 0xF9, 0xA6, 0xE8, 0xCC, 0x7C, 0x9F, 0xB3,
    0x22, 0xDA, 0x37, 0xF1, 0x2F, 0x4E, 0xE7, 0x6A, 0x75, 0xA8,
    0x26, 0xEB, 0x3F, 0x6C, 0x69, 0x20, 0x87, 0x62, 0xA7, 0x41,
    0x96, 0x90, 0xB4, 0x42, 0x63, 0x99, 0xD0, 0x4D, 0x97, 0xBE,
    0x40, 0xCF, 0x84, 0xE5, 0x1D, 0x5A, 0x0C, 0x7F, 0xC7, 0xEA,
    0xEE, 0xEC, 0x00, 0xD5, 0x49, 0x2D, 0x51, 0xAD, 0xB9, 0x89,
    0x1A, 0x80, 0xF5, 0xFE, 0x91, 0x01, 0x3C, 0x73, 0x93, 0x48,
    0xA0, 0xE0, 0x94, 0xAA, 0x39, 0x8F, 0x58, 0xE2, 0x31, 0x0B,
    0xBB, 0xCE, 0x4C, 0xD2, 0x56, 0xC2, 0x5E, 0x27, 0xB6, 0xFB,
    0x65, 0xAE, 0x9A, 0xB0, 0xEF, 0x36, 0xC5, 0x72, 0x5B, 0x7E,
    0x54, 0x2C, 0x0F, 0xF6, 0xA9, 0x85, 0x2A, 0xB1, 0x55, 0x60,
    0xBD, 0x10, 0x86, 0xF7, 0xC1, 0x88, 0x12, 0xED, 0x67, 0xC4,
    0x74, 0x30, 0x1B, 0xBC, 0x77, 0x52, 0x3E, 0x8C, 0xE6, 0xFF,
    0x15, 0xDE, 0x6D, 0x14, 0xA2, 0xCD, 0xA3, 0xD6, 0x17, 0x81,
    0x8D, 0x68, 0xA5, 0xFA, 0x3A, 0x04, 0x21, 0x1F, 0xAC, 0x05,
    0xA4, 0x76, 0x11, 0x70, 0x9E, 0x46, 0x24, 0x5D, 0xC6, 0xE4,
    0x95, 0x82, 0x1C, 0xBA, 0x59, 0x09, 0xD9, 0x44, 0x98, 0x92,
    0x07, 0xAF, 0xC8, 0x45, 0x4B, 0x35, 0x0A, 0x0D, 0xFC, 0x9D,
    0x16, 0x3B, 0xD3, 0x7D, 0xD1, 0xF4, 0xFD, 0xCA, 0x8E, 0x4F,
    0xE3, 0xC9, 0x8B, 0xDC, 0x5C, 0xC0, 0x1E, 0x9B, 0x18, 0x02,
    0x47, 0x03, 0x2B, 0x0E, 0x25, 0x06, 0x6E, 0xF8, 0x5F, 0xBF,
    0x8A, 0x7B, 0x50, 0xD8, 0x79, 0x9C, 0xAB, 0x43, 0x53, 0xCB,
    0x66, 0x4A, 0xB2, 0xF0, 0xE9, 0x19, 0x29, 0x7A, 0xC3, 0x08,
    0x83, 0xDB, 0x64, 0x13, 0x2E, 0x28 };

const BYTE trans_tbl[] = { 0x4B, 0x56, 0x39, 0x36, 0x47, 0x4D, 0x4A, 0x59, 0x48, 0x37,
  0x51, 0x46, 0x35, 0x54, 0x43, 0x57, 0x34, 0x55, 0x33, 0x58, 
  0x5A, 0x50, 0x52, 0x53, 0x44, 0x4E, 0x00 };

const BYTE trans_box[] = { 0x23, 0xDD, 0x78, 0xB5, 0x33, 0x6F, 0xD4, 0xF9, 0xA6, 0xE8,
  0xCC, 0x7C, 0x9F, 0xB3, 0x22, 0xDA, 0x32, 0xDF, 0x71, 0xB7,
  0x61, 0x3D, 0x6B, 0x57, 0xD7, 0xA1, 0x34, 0x38, 0xF2, 0xE1,
  0xF3, 0xB8, 0x1A, 0x80, 0xF5, 0xFE, 0x91, 0x01, 0x3C, 0x73,
  0x93, 0x48, 0xA0, 0xE0, 0x94, 0xAA, 0x39, 0x8F, 0x58, 0xE2,
  0x31, 0x0B, 0xBB, 0xCE, 0x4C, 0xD2, 0x56, 0xC2, 0x5E, 0x27,
  0xB6, 0xFB, 0x65, 0xAE, 0x55, 0x60, 0xBD, 0x10, 0x86, 0xF7,
  0xC1, 0x88, 0x12, 0xED, 0x67, 0xC4, 0x74, 0x30, 0x1B, 0xBC,
  0x9A, 0xB0, 0xEF, 0x36, 0xC5, 0x72, 0x5B, 0x7E, 0x54, 0x2C,
  0x0F, 0xF6, 0xA9, 0x85, 0x2A, 0xB1, 0x37, 0xF1, 0x2F, 0x4E,
  0xE7, 0x6A, 0x75, 0xA8, 0x26, 0xEB, 0x3F, 0x6C, 0x69, 0x20,
  0x87, 0x62, 0x8D, 0x68, 0xA5, 0xFA, 0x3A, 0x04, 0x21, 0x1F,
  0xAC, 0x05, 0xA4, 0x76, 0x11, 0x70, 0x9E, 0x46, 0x24, 0x5D,
  0xC6, 0xE4, 0x95, 0x82, 0x1C, 0xBA, 0x59, 0x09, 0xD9, 0x44,
  0x98, 0x92, 0x07, 0xAF, 0xA7, 0x41, 0x96, 0x90, 0xB4, 0x42,
  0x63, 0x99, 0xD0, 0x4D, 0x97, 0xBE, 0x40, 0xCF, 0x84, 0xE5,
  0x1D, 0x5A, 0x0C, 0x7F, 0xC7, 0xEA, 0xEE, 0xEC, 0x00, 0xD5,
  0x49, 0x2D, 0x51, 0xAD, 0xB9, 0x89, 0x77, 0x52, 0x3E, 0x8C,
  0xE6, 0xFF, 0x15, 0xDE, 0x6D, 0x14, 0xA2, 0xCD, 0xA3, 0xD6,
  0x17, 0x81, 0xC8, 0x45, 0x4B, 0x35, 0x0A, 0x0D, 0xFC, 0x9D,
  0x16, 0x3B, 0xD3, 0x7D, 0xD1, 0xF4, 0xFD, 0xCA, 0x25, 0x06,
  0x6E, 0xF8, 0x5F, 0xBF, 0x8A, 0x7B, 0x50, 0xD8, 0x79, 0x9C,
  0xAB, 0x43, 0x53, 0xCB, 0x8E, 0x4F, 0xE3, 0xC9, 0x8B, 0xDC,
  0x5C, 0xC0, 0x1E, 0x9B, 0x18, 0x02, 0x47, 0x03, 0x2B, 0x0E,
  0x66, 0x4A, 0xB2, 0xF0, 0xE9, 0x19, 0x29, 0x7A, 0xC3, 0x08,
  0x83, 0xDB, 0x64, 0x13, 0x2E, 0x28 };

const BYTE sig_box[] = { 
  0x8D, 0x8D, 0x5B, 0x1F, 0x4F, 0x79, 0xAD, 0xFF, 0x51, 0xC4,
  0x6D, 0xFF, 0x07, 0x51, 0xF5, 0x41, 0x2B, 0x23, 0x0C, 0xF1,
  0x64, 0xE7, 0x2C, 0x25, 0x62, 0x3B, 0x8C, 0xFE, 0x63, 0x81,
  0xBB, 0x2A, 0x4E, 0xC1, 0x52, 0xBC, 0x80, 0xCC, 0x2A, 0xE3,
  0x33, 0x39, 0xE4, 0xF0, 0xE7, 0x71, 0x1B, 0xEB, 0x29, 0xAD,
  0x0A, 0xC7, 0x24, 0x93, 0xB8, 0x15, 0xAF, 0xC7, 0x98, 0xCA,
  0xF3, 0x27, 0x8A, 0x1F, 0xA0, 0xA6, 0x8B, 0x60, 0xD7, 0x98,
  0x92, 0xF2, 0x28, 0x17, 0x44, 0xCE, 0x3D, 0xC1, 0xA2, 0x9A,
  0x55, 0xFA, 0x26, 0x1D, 0x34, 0xC8, 0x69, 0x3E, 0x76, 0x50,
  0xE3, 0xD7, 0x3D, 0x6D, 0xB0, 0xB0, 0x9A, 0xF1, 0xF7, 0x9F,
  0xCF, 0xDB, 0xE7, 0xE7, 0x1B, 0xED, 0x02, 0x5E, 0x12, 0x13,
  0xDE, 0x8C, 0xF7, 0x33, 0x59, 0xC8, 0x3D, 0xD7, 0x19, 0xD0,
  0xCB, 0xA4, 0x91, 0x3B, 0x63, 0x1E, 0x79, 0x8B, 0x9D, 0x6B,
  0x85, 0xC9, 0x0E, 0x73, 0xE6, 0x23, 0x48, 0x44, 0x70, 0xD4,
  0x66, 0xE3, 0x26, 0xA3, 0xF0, 0xFF, 0xD7, 0x64, 0xAB, 0xF7,
  0x89, 0xF2, 0xAF, 0x70, 0x51, 0xEB, 0xBB, 0x20, 0x4A, 0x15,
  0x22, 0x95, 0xA0, 0x57, 0x1D, 0xFC, 0xD9, 0xE9, 0x41, 0xFD,
  0x06, 0xE8, 0x94, 0xDB, 0xD0, 0x15, 0x18, 0x1D, 0xEA, 0x6B,
  0xC3, 0xD2, 0xE7, 0xAC, 0x58, 0x73, 0xA1, 0x19, 0xF4, 0x34,
  0xDC, 0xF2, 0x45, 0xE2, 0x94, 0xE5, 0x33, 0x2B, 0xE7, 0x01 };

const char actid_prefix_tabl[] = {
  0x36,0x37,0x33,0x41,0x34,0x34,0x44,0x33,0x35,0x42,0x33,0x36,0x30,0x38,0x45,0x35,
  0x43,0x36,0x30,0x33,0x44,0x37,0x37,0x35,0x43,0x37,0x36,0x32,0x31,0x36,0x46,0x35,
  0x35,0x35,0x45,0x30,0x30,0x30,0x44,0x30,0x34,0x42,0x36,0x37,0x31,0x38,0x45,0x33,
  0x33,0x45,0x39,0x33,0x46,0x33,0x35,0x38,0x38,0x37,0x41,0x38,0x41,0x33,0x36,0x30,
  0x44,0x32,0x46,0x34,0x36,0x38,0x45,0x33,0x31,0x33,0x44,0x43,0x37,0x42,0x33,0x45,
  0x30,0x34,0x37,0x45,0x30,0x38,0x46,0x31,0x30,0x41,0x35,0x31,0x42,0x37,0x35,0x35,
  0x36,0x31,0x42,0x35,0x4C,0x35,0x35,0x35,0x37,0x36,0x42,0x36,0x33,0x42,0x46,0x32,
  0x44,0x37,0x37,0x35,0x30,0x46,0x30,0x39,0x35,0x35,0x37,0x41,0x46,0x36,0x36,0x31,
  0x46,0x31,0x34,0x38,0x34,0x39,0x46,0x39,0x34,0x46,0x32,0x36,0x35,0x32,0x41,0x39,
  0x30,0x33,0x41,0x31,0x30,0x45,0x39,0x30,0x37,0x34,0x45,0x36,0x31,0x45,0x41,0x34,
  0x46,0x45,0x37,0x45,0x38,0x33,0x41,0x36,0x46,0x35,0x30,0x39,0x30,0x41,0x44,0x36,
  0x31,0x46,0x33,0x46,0x33,0x36,0x35,0x44,0x31,0x43,0x36,0x37,0x44,0x41,0x32,0x32,
  0x41,0x34,0x37,0x38,0x46,0x41,0x31,0x37,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

const char* alphdigest = "0123456789QWERTYUIOPASDFGHJKLZXCVBNM";

const char* license_template1 =
"<!--                                                         \n"
"   Source Insight 4.x License File                           \n"
"                                                             \n"
"   DO NOT EDIT THIS FILE. Doing so will render it unusable.  \n"
"                                                             \n"
"   This license was created for:                             \n"
"                                                             \n"
"        %s                                                   \n"
"        %s                                                   \n"
"                                                             \n"
"                                                             \n"
"-->                                                          \n"
"<SourceInsightLicense>                                       \n"
"   <LicenseProperties                                        \n"
"      ActId=\"%s\"                                          \n"
"      Serial=\"%s\"                                         \n"
"      LicensedUser=\"%s\"                                   \n"
"      Organization=\"%s\"                                   \n"
"      Email=\"%s\"                                          \n"
"      Type=\"Standard\"                                     \n"
"      Version=\"4\"                                         \n"
"      MinorVersion=\"0\"                                    \n"
"      Date=\"%s\"                                           \n"
"    />                                                        \n";

const char* license_template2 =
"<Signature				   \n"
"		Value=\"%s\"        \n"
"	/>                      \n"
"</SourceInsightLicense>    \n";

auto SiKeygen::encode(const std::string& src, size_t size, BYTE** encData, size_t round, size_t pos)->bool
{
    *encData = new(std::nothrow) BYTE[round];

    if (*encData == nullptr) return false;


    for (size_t i = 0; i < round; i++)
    {
        auto c = enc_tbl[(pos + i + src[0]) % 256];

        for (size_t j = 1; j < size; j++)
        {
            c = enc_tbl[c ^ src[j]];
        }

        (*encData)[i] = c;
    }

    return true;
}

auto SiKeygen::getComputerName()->std::string
{
    char szCompterName[0x100];
    DWORD dwSize = sizeof(szCompterName);
    std::string result;

    if (::GetComputerNameA(szCompterName, &dwSize))
    {
        szCompterName[dwSize] = 0;
        result = szCompterName;
    }

    return result;
}

auto SiKeygen::getSystemDiskSerial()->std::string
{
    char drvName[0x100] = { 0 };
    char szVolumeGUID[0x100] = { 0 };
    const char* lpzVolSerialPrefix = "\\\\?\\Volume{\0";
    std::string volSerial;
    // 从调用进程的环境变量中取系统盘
    ::GetEnvironmentVariableA("SystemDrive", drvName, sizeof(drvName) - 1);

    if (strlen(drvName) > 0x100) strcpy_s(drvName, sizeof(drvName), "C:\\");
    else strcat_s(drvName, sizeof(drvName), "\\");

    if (!::GetVolumeNameForVolumeMountPointA(drvName, szVolumeGUID, sizeof(szVolumeGUID) - 1)) return "";
    
    if (!memcmp(lpzVolSerialPrefix, szVolumeGUID, strlen(lpzVolSerialPrefix)))
    {
        auto beg = strchr(szVolumeGUID, '{');
        auto end = strchr(szVolumeGUID, '}');

        if (beg != nullptr && end != nullptr)
        {
            volSerial.resize(end - beg - 1);

            memcpy(&volSerial[0], szVolumeGUID + (size_t)(beg - szVolumeGUID) + 1, (size_t)(end - beg - 1));
        }
    }
    
    return volSerial;
}

auto SiKeygen::getLoginUser()->std::string
{
    unique_handle_t hToken;
    DWORD ReturnLength;
    PTOKEN_USER pTokenUser = nullptr;
    LPSTR pszSid = nullptr;
    std::string result;
    
    do 
    {
        if (!::OpenProcessToken(::GetCurrentProcess(), 8u, (PHANDLE)&hToken)) break;

        if (!GetTokenInformation(hToken.get(), TokenUser, nullptr, 0, &ReturnLength) &&
            GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            break;
        }

        pTokenUser = (PTOKEN_USER)new(std::nothrow) BYTE[ReturnLength];

        if (pTokenUser == nullptr) break;

        if (!::GetTokenInformation(hToken.get(), TokenUser, pTokenUser, ReturnLength, &ReturnLength)) break;
            
        if (!ConvertSidToStringSidA(pTokenUser->User.Sid, &pszSid)) break;
 
        result = pszSid;

    } while (false);

    if (pTokenUser) delete[] pTokenUser;

    if (pszSid) LocalFree(pszSid);
    
    return result;
}

auto SiKeygen::makeDirectory(const std::string& path)->bool
{
    size_t beg = 0;
    size_t end = 0;

    while ((end = path.find_first_of("\\/", beg)) != std::string::npos)
    {
        auto curDir = path.substr(0, end);
        if (!::PathIsDirectoryA(curDir.c_str()))
        {
            if ((!::CreateDirectoryA(curDir.c_str(), nullptr)) && (GetLastError() != ERROR_ALREADY_EXISTS))
                return false;
        }

        beg = end + 1;
    }

    if (!::PathIsDirectoryA(path.c_str()))
    {
        if ((!::CreateDirectoryA(path.c_str(), nullptr)) && (GetLastError() != ERROR_ALREADY_EXISTS))
            return false;
    }

    return true;
}

auto SiKeygen::genNocontinuousNumber()->std::string
{
    const char* number = "0123456789";
    std::string reslt;
    auto rp = rand() % 10;

    reslt += number[rp];
    reslt += number[(rp + 2) % 10];
    reslt += number[(((rp + 2) % 10) + 2) % 10];
    reslt += number[rp];
    reslt += number[rp];
    reslt += number[rp];

    return reslt;
}

auto SiKeygen::transform(const std::string& str)->std::string
{
    std::string result;

    for (int i = 0; i < 4; i++)
    {
        auto c = trans_box[str[0] + i];
        
        for (int j = 1; j < 15; j++)
        {
            c = trans_box[c ^ str[j]];
        }

        result += trans_tbl[c % 26];
    }

    result.reserve();

    return result;
}

auto SiKeygen::randomChoice(const char* table, int count)->std::string
{
    std::string result;

    auto len = strlen(table);

    for (int i = 0; i < count; i++)
    {
        result += table[rand() % len];
    }

    return result;
}

auto SiKeygen::genActId()->std::string
{
    auto diskSerial = getSystemDiskSerial();

    if (diskSerial.size() == 0) return "";

    auto logUsr = getLoginUser();

    if (logUsr.size() == 0) return "";

    auto computerName = getComputerName();

    if (computerName.size() == 0) return "";

    BYTE* actIdByts = nullptr;
    std::stringstream actId;
    // pos必须保证是4的倍数
    auto pos = rand() % strlen(actid_prefix_tabl);
    pos = ((pos - 1) / 4 + 1) * 4;

    actId << actid_prefix_tabl[pos] << actid_prefix_tabl[pos + 1] <<
        actid_prefix_tabl[pos + 2] << actid_prefix_tabl[pos + 3];

    if (encode(diskSerial + logUsr + computerName, diskSerial.size() + logUsr.size() + computerName.size(), &actIdByts, 4, 0x7A9))
    {
        actId << *((PDWORD)actIdByts);

        delete[] actIdByts;

        return actId.str();
    }

    return "";
}

auto SiKeygen::genSerial()->std::string
{
    std::stringstream sstr;
    
    sstr << "S4U" << randomChoice("RG", 1) << "-" << randomChoice(alphdigest, 1) << randomChoice("RGDF", 1) <<
        randomChoice(alphdigest, 2) << "-" << randomChoice(alphdigest, 4) << '-';

    std::stringstream result;

    result << sstr.str() << transform(sstr.str());

    return result.str();
}

auto SiKeygen::genSignature(const std::string& src)->std::string
{
    BYTE* encDat = nullptr;
    auto bOk = encode(src, src.size() + 1, &encDat, 128, 1968);

    if (bOk)
    {
        auto sig = CCBase64::b64_encode(encDat,128);
        delete[] encDat;

        return sig;
    }

    return "";
}

auto SiKeygen::genLicenseFile(const std::string& name, const std::string& company, const std::string& email)->bool
{
    CStringA license;
    std::string tpPartialLicense;
    srand(time(nullptr));
    BYTE* encDat = nullptr;
    bool bRet = false;
    time_t regTimeStamp;
    std::stringstream date;
    tm regTime;

    do 
    {
        auto serial = genSerial();

        if (serial.size() == 0) break;

        auto actId = genActId();

        if (actId.size() == 0) break;

        ::time(&regTimeStamp);
        if (::localtime_s(&regTime, &regTimeStamp) != 0) break;

        date << regTime.tm_year + 1900 << "-" << regTime.tm_mon + 1 << "-" << regTime.tm_mday;

        license.Format(license_template1, 
            name.c_str(), 
            company.c_str(), 
            actId.c_str(),
            serial.c_str(),
            name.c_str(),
            company.c_str(),
            email.c_str(), 
            date.str().c_str()
           );

        tpPartialLicense = license.GetBuffer();

        tpPartialLicense.erase(std::remove(tpPartialLicense.begin(), tpPartialLicense.end(), '\t'), tpPartialLicense.end());
        tpPartialLicense.erase(std::remove(tpPartialLicense.begin(), tpPartialLicense.end(), '\n'), tpPartialLicense.end());
        tpPartialLicense.erase(std::remove(tpPartialLicense.begin(), tpPartialLicense.end(), '\r'), tpPartialLicense.end());
        tpPartialLicense.erase(std::remove(tpPartialLicense.begin(), tpPartialLicense.end(), ' '), tpPartialLicense.end());

        auto sig = genSignature(tpPartialLicense);

        if (sig.size() == 0) break;

        license.AppendFormat(license_template2, sig.c_str());

        std::ofstream fout("si4.lic");

        fout.write(license.GetBuffer(),license.GetLength());

        bRet = true;
    } while (false);
    
    return bRet;
}

auto SiKeygen::importLicenseFile()->bool
{
    CHAR szPath[0x100];
    auto len = ::GetEnvironmentVariableA("SystemDrive", szPath, sizeof(szPath) - 1);
    szPath[len] = 0;
    std::string dir = szPath;
    dir += "\\ProgramData\\Source Insight\\4.0";

    if (!makeDirectory(dir)) return false;

    len = ::GetCurrentDirectoryA(sizeof(szPath) - 1, szPath);
    szPath[len] = 0;

    std::string src = szPath;
    auto dest = dir + "\\si4.lic";
    src += "\\si4.lic";
    
    ::DeleteFileA(dest.c_str());

    return ::MoveFileA(src.c_str(), dest.c_str());
}